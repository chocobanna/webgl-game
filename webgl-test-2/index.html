<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGL2 System - Free Camera + WASD/QE</title>
  <style>
    html, body { margin: 0; height: 100%; background: #111; }
    canvas { width: 100%; height: 100%; display: block; outline: none; }
    .hud {
      position: fixed; top: 10px; left: 10px;
      color: #ddd; font: 12px/1.35 system-ui, sans-serif;
      background: rgba(0,0,0,.45); padding: 8px 10px; border-radius: 10px;
      user-select: none;
    }
    .hud b { color: #fff; }
    .hud kbd {
      background: rgba(255,255,255,.1);
      border: 1px solid rgba(255,255,255,.15);
      border-bottom-color: rgba(255,255,255,.25);
      padding: 1px 6px;
      border-radius: 6px;
      font: 11px/1.2 ui-monospace, SFMono-Regular, Menlo, monospace;
      margin-right: 4px;
    }
  </style>
</head>
<body>
  <canvas id="gl" tabindex="0"></canvas>
  <div class="hud">
    <b>WebGL2 System</b><br/>
    Drag: look • Wheel: forward/back<br/>
    <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> move • <kbd>Q</kbd>/<kbd>E</kbd> down/up • <kbd>Shift</kbd> faster
  </div>

<script type="module">
class GLSystem {
  /** @param {HTMLCanvasElement} canvas */
  constructor(canvas) {
    const gl = canvas.getContext("webgl2", { antialias: true, alpha: false });
    if (!gl) throw new Error("WebGL2 not supported.");
    this.canvas = canvas;
    this.gl = gl;

    // Timing
    this.time = 0;
    this.dt = 0;
    this._last = performance.now();

    // Free camera (position IS the movement center)
    this.camera = {
      pos: [0, 1.25, 6],  // start slightly above so you see something
      yaw: 0.0,
      pitch: 0.0,
      dragging: false,
      lastX: 0,
      lastY: 0,
    };

    // Keys
    this.keys = new Set();

    this._installResize();
    this._installInput();
    this._installKeyboard();
    this._setDefaultState();

    // Program + mesh
    this.program = createProgram(gl, VERT_SRC, FRAG_SRC);
    this.mesh = createCubeMesh(gl); // Fix B: correct outer faces

    this.u = {
      uMVP: gl.getUniformLocation(this.program, "uMVP"),
      uModel: gl.getUniformLocation(this.program, "uModel"),
      uLightDir: gl.getUniformLocation(this.program, "uLightDir"),
      uColor: gl.getUniformLocation(this.program, "uColor"),
    };

    this._raf = requestAnimationFrame(this._frame);
  }

  _setDefaultState() {
    const gl = this.gl;
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK); // Fix B geometry => default CCW fronts are correct

    gl.clearColor(0.06, 0.06, 0.08, 1.0);
  }

  _installResize() {
    const resize = () => {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = Math.floor(this.canvas.clientWidth * dpr);
      const h = Math.floor(this.canvas.clientHeight * dpr);
      if (this.canvas.width !== w || this.canvas.height !== h) {
        this.canvas.width = w;
        this.canvas.height = h;
        this.gl.viewport(0, 0, w, h);
      }
    };
    new ResizeObserver(resize).observe(this.canvas);
    window.addEventListener("resize", resize, { passive: true });
    resize();
  }

  _installInput() {
    const c = this.canvas;
    const cam = this.camera;

    c.addEventListener("pointerdown", (e) => {
      c.focus();
      cam.dragging = true;
      cam.lastX = e.clientX;
      cam.lastY = e.clientY;
      c.setPointerCapture(e.pointerId);
    });

    c.addEventListener("pointerup", (e) => {
      cam.dragging = false;
      c.releasePointerCapture(e.pointerId);
    });

    c.addEventListener("pointercancel", () => { cam.dragging = false; });

    c.addEventListener("pointermove", (e) => {
      if (!cam.dragging) return;

      const dx = e.clientX - cam.lastX;
      const dy = e.clientY - cam.lastY;
      cam.lastX = e.clientX;
      cam.lastY = e.clientY;

      const lookSpeed = 0.005;
      cam.yaw += dx * lookSpeed;
      cam.pitch += dy * lookSpeed;

      // Clamp pitch to ±90° (minus epsilon so up never degenerates)
      const limit = (Math.PI / 2) - 0.0001;
      cam.pitch = clamp(cam.pitch, -limit, limit);
    });

    // Wheel = move forward/back (zoom without the orbit nonsense)
    c.addEventListener("wheel", (e) => {
      e.preventDefault();
      const cam = this.camera;
      const forward = cameraForward(cam.yaw, cam.pitch);
      const speed = 0.01; // tune
      // deltaY > 0 is scroll down (usually "zoom out"/back)
      const step = e.deltaY * speed;
      cam.pos[0] += forward[0] * step;
      cam.pos[1] += forward[1] * step;
      cam.pos[2] += forward[2] * step;
    }, { passive: false });

    // Double click = reset
    c.addEventListener("dblclick", () => {
      cam.pos = [0, 1.25, 6];
      cam.yaw = 0.0;
      cam.pitch = 0.0;
    });
  }

  _installKeyboard() {
    const onKeyDown = (e) => {
      const k = e.key.toLowerCase();
      if (["w","a","s","d","q","e","shift"].includes(k)) e.preventDefault();
      this.keys.add(k);
    };
    const onKeyUp = (e) => this.keys.delete(e.key.toLowerCase());

    this.canvas.addEventListener("keydown", onKeyDown);
    this.canvas.addEventListener("keyup", onKeyUp);
    window.addEventListener("keydown", onKeyDown, { passive: false });
    window.addEventListener("keyup", onKeyUp, { passive: true });
  }

  _applyKeyboardMovement() {
    const cam = this.camera;

    const forward = cameraForward(cam.yaw, cam.pitch);
    const worldUp = [0, 1, 0];
    let right = normalize3(cross3(worldUp, forward));
    let up = normalize3(cross3(forward, right));

    let x = 0, y = 0, z = 0;
    if (this.keys.has("a")) x -= 1;
    if (this.keys.has("d")) x += 1;
    if (this.keys.has("q")) y -= 1;
    if (this.keys.has("e")) y += 1;
    if (this.keys.has("w")) z += 1;
    if (this.keys.has("s")) z -= 1;

    const mag = Math.hypot(x, y, z);
    if (mag < 1e-6) return;

    const baseSpeed = 4.0; // units/sec
    const speed = baseSpeed * (this.keys.has("shift") ? 2.5 : 1.0);
    const step = (speed * this.dt) / mag;

    cam.pos[0] += right[0] * (x * step) + up[0] * (y * step) + forward[0] * (z * step);
    cam.pos[1] += right[1] * (x * step) + up[1] * (y * step) + forward[1] * (z * step);
    cam.pos[2] += right[2] * (x * step) + up[2] * (y * step) + forward[2] * (z * step);
  }

  _frame = (now) => {
    const gl = this.gl;

    this.dt = (now - this._last) * 0.001;
    this._last = now;
    this.time += this.dt;

    this._applyKeyboardMovement();

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const aspect = this.canvas.width / this.canvas.height;
    const proj = Mat4.perspective(60 * Math.PI/180, aspect, 0.1, 200.0);

    const cam = this.camera;
    const forward = cameraForward(cam.yaw, cam.pitch);

    // Robust up selection near poles
    const worldUp = [0, 1, 0];
    const altUp = [0, 0, 1];
    const upRef = Math.abs(dot3(forward, worldUp)) > 0.999 ? altUp : worldUp;

    const center = [
      cam.pos[0] + forward[0],
      cam.pos[1] + forward[1],
      cam.pos[2] + forward[2],
    ];

    const view = Mat4.lookAt(cam.pos, center, upRef);

    const model = Mat4.identity(); // static cube
    const mvp = Mat4.mul(proj, Mat4.mul(view, model));

    gl.useProgram(this.program);
    gl.bindVertexArray(this.mesh.vao);

    gl.uniformMatrix4fv(this.u.uMVP, false, mvp);
    gl.uniformMatrix4fv(this.u.uModel, false, model);
    gl.uniform3fv(this.u.uLightDir, normalize3([0.6, 1.0, 0.4]));
    gl.uniform3fv(this.u.uColor, [0.25, 0.8, 1.0]);

    gl.drawElements(gl.TRIANGLES, this.mesh.indexCount, gl.UNSIGNED_SHORT, 0);

    gl.bindVertexArray(null);
    this._raf = requestAnimationFrame(this._frame);
  };
}

/** =========================
 *  Shaders
 *  ========================= */

const VERT_SRC = `#version 300 es
precision highp float;

layout(location=0) in vec3 aPos;
layout(location=1) in vec3 aNormal;

uniform mat4 uMVP;
uniform mat4 uModel;

out vec3 vN;
out vec3 vWPos;

void main() {
  vec4 wPos = uModel * vec4(aPos, 1.0);
  vWPos = wPos.xyz;
  vN = mat3(uModel) * aNormal;
  gl_Position = uMVP * vec4(aPos, 1.0);
}
`;

const FRAG_SRC = `#version 300 es
precision highp float;

in vec3 vN;
in vec3 vWPos;

uniform vec3 uLightDir;
uniform vec3 uColor;

out vec4 outColor;

void main() {
  vec3 N = normalize(vN);
  vec3 L = normalize(uLightDir);

  float diff = max(dot(N, L), 0.0);
  float ambient = 0.18;

  vec3 V = normalize(-vWPos);
  vec3 H = normalize(L + V);
  float spec = pow(max(dot(N, H), 0.0), 64.0) * 0.25;

  vec3 col = uColor * (ambient + diff) + spec;
  outColor = vec4(col, 1.0);
}
`;

/** =========================
 *  Cube mesh (Fix B: CCW outward)
 *  ========================= */

function createCubeMesh(gl) {
  const positions = new Float32Array([
    // +X
     1,-1, 1,   1,-1,-1,   1, 1,-1,   1, 1, 1,
    // -X
    -1,-1,-1,  -1,-1, 1,  -1, 1, 1,  -1, 1,-1,
    // +Y
    -1, 1, 1,   1, 1, 1,   1, 1,-1,  -1, 1,-1,
    // -Y
    -1,-1,-1,   1,-1,-1,   1,-1, 1,  -1,-1, 1,
    // +Z
    -1,-1, 1,   1,-1, 1,   1, 1, 1,  -1, 1, 1,
    // -Z
     1,-1,-1,  -1,-1,-1,  -1, 1,-1,   1, 1,-1
  ]);

  const normals = new Float32Array([
    // +X
     1,0,0,  1,0,0,  1,0,0,  1,0,0,
    // -X
    -1,0,0, -1,0,0, -1,0,0, -1,0,0,
    // +Y
     0,1,0,  0,1,0,  0,1,0,  0,1,0,
    // -Y
     0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
    // +Z
     0,0,1,  0,0,1,  0,0,1,  0,0,1,
    // -Z
     0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1
  ]);

  const indices = new Uint16Array([
     0, 1, 2,   0, 2, 3,
     4, 5, 6,   4, 6, 7,
     8, 9,10,   8,10,11,
    12,13,14,  12,14,15,
    16,17,18,  16,18,19,
    20,21,22,  20,22,23
  ]);

  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

  const nrmBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, nrmBuf);
  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

  const idxBuf = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  gl.bindVertexArray(null);
  return { vao, indexCount: indices.length };
}

/** =========================
 *  Shader utils
 *  ========================= */

function createShader(gl, type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    const msg = gl.getShaderInfoLog(s) || "Unknown shader error";
    gl.deleteShader(s);
    throw new Error(msg);
  }
  return s;
}

function createProgram(gl, vsSrc, fsSrc) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  gl.deleteShader(vs);
  gl.deleteShader(fs);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    const msg = gl.getProgramInfoLog(p) || "Unknown link error";
    gl.deleteProgram(p);
    throw new Error(msg);
  }
  return p;
}

/** =========================
 *  Mat4 (column-major)
 *  ========================= */

const Mat4 = {
  identity() {
    return new Float32Array([
      1,0,0,0,
      0,1,0,0,
      0,0,1,0,
      0,0,0,1
    ]);
  },

  perspective(fovy, aspect, near, far) {
    const f = 1.0 / Math.tan(fovy / 2);
    const nf = 1 / (near - far);
    const out = new Float32Array(16);
    out[0] = f / aspect;
    out[5] = f;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[14] = (2 * far * near) * nf;
    return out;
  },

  lookAt(eye, center, up) {
    const z = normalize3(sub3(eye, center)); // forward (camera space -Z)
    const x = normalize3(cross3(up, z));     // right
    const y = cross3(z, x);                  // corrected up

    const out = Mat4.identity();
    out[0] = x[0]; out[4] = x[1]; out[8]  = x[2];
    out[1] = y[0]; out[5] = y[1]; out[9]  = y[2];
    out[2] = z[0]; out[6] = z[1]; out[10] = z[2];

    out[12] = -dot3(x, eye);
    out[13] = -dot3(y, eye);
    out[14] = -dot3(z, eye);
    return out;
  },

  mul(a, b) {
    const out = new Float32Array(16);
    for (let c = 0; c < 4; c++) {
      for (let r = 0; r < 4; r++) {
        out[c*4 + r] =
          a[0*4 + r] * b[c*4 + 0] +
          a[1*4 + r] * b[c*4 + 1] +
          a[2*4 + r] * b[c*4 + 2] +
          a[3*4 + r] * b[c*4 + 3];
      }
    }
    return out;
  }
};

/** =========================
 *  Vec3 helpers
 *  ========================= */

function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function sub3(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function dot3(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
function cross3(a, b) {
  return [
    a[1]*b[2] - a[2]*b[1],
    a[2]*b[0] - a[0]*b[2],
    a[0]*b[1] - a[1]*b[0]
  ];
}
function len3(v) { return Math.hypot(v[0], v[1], v[2]); }
function normalize3(v) {
  const L = len3(v) || 1;
  return [v[0]/L, v[1]/L, v[2]/L];
}

/** yaw/pitch -> forward direction */
function cameraForward(yaw, pitch) {
  const cy = Math.cos(yaw), sy = Math.sin(yaw);
  const cp = Math.cos(pitch), sp = Math.sin(pitch);
  // Forward points where camera looks
  return normalize3([cp * sy, sp, cp * cy]);
}

/** Boot */
const canvas = document.getElementById("gl");
new GLSystem(canvas);
</script>
</body>
</html>
