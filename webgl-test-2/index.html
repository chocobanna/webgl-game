<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGL2 System</title>
  <style>
    html, body { margin: 0; height: 100%; background: #111; }
    canvas { width: 100%; height: 100%; display: block; }
    .hud {
      position: fixed; top: 10px; left: 10px;
      color: #ddd; font: 12px/1.3 system-ui, sans-serif;
      background: rgba(0,0,0,.45); padding: 8px 10px; border-radius: 8px;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>
  <div class="hud">
    WebGL2 System<br/>
    Drag = orbit-ish (yaw/pitch) â€¢ Wheel = zoom
  </div>

<script type="module">
/** =========================
 *  WebGL2 System (mini-engine)
 *  ========================= */

class GLSystem {
  /** @param {HTMLCanvasElement} canvas */
  constructor(canvas) {
    const gl = canvas.getContext("webgl2", { antialias: true, alpha: false });
    if (!gl) throw new Error("WebGL2 not supported.");
    this.canvas = canvas;
    this.gl = gl;

    // State
    this.time = 0;
    this.dt = 0;
    this._last = performance.now();

    // Camera-ish controls
    this.camera = {
      yaw: 0.6,
      pitch: 0.4,
      distance: 5.0,
      target: [0, 0, 0],
      dragging: false,
      lastX: 0,
      lastY: 0,
    };

    // Resize + default GL settings
    this._installResize();
    this._installInput();
    this._setDefaultState();

    // Simple scene objects
    this.program = createProgram(gl, VERT_SRC, FRAG_SRC);
    this.mesh = createCubeMesh(gl);

    // Uniform locations
    this.u = {
      uMVP: gl.getUniformLocation(this.program, "uMVP"),
      uModel: gl.getUniformLocation(this.program, "uModel"),
      uLightDir: gl.getUniformLocation(this.program, "uLightDir"),
      uColor: gl.getUniformLocation(this.program, "uColor"),
    };

    // Start
    this._raf = requestAnimationFrame(this._frame);
  }

  destroy() {
    cancelAnimationFrame(this._raf);
  }

  _setDefaultState() {
    const gl = this.gl;
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.clearColor(0.06, 0.06, 0.08, 1.0);
  }

  _installResize() {
    const resize = () => {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const w = Math.floor(this.canvas.clientWidth * dpr);
      const h = Math.floor(this.canvas.clientHeight * dpr);
      if (this.canvas.width !== w || this.canvas.height !== h) {
        this.canvas.width = w;
        this.canvas.height = h;
        this.gl.viewport(0, 0, w, h);
      }
    };
    this._resize = resize;
    new ResizeObserver(resize).observe(this.canvas);
    window.addEventListener("resize", resize, { passive: true });
    resize();
  }

  _installInput() {
    const c = this.canvas;
    const cam = this.camera;

    c.addEventListener("pointerdown", (e) => {
      cam.dragging = true;
      cam.lastX = e.clientX;
      cam.lastY = e.clientY;
      c.setPointerCapture(e.pointerId);
    });

    c.addEventListener("pointerup", (e) => {
      cam.dragging = false;
      c.releasePointerCapture(e.pointerId);
    });

    c.addEventListener("pointermove", (e) => {
      if (!cam.dragging) return;
      const dx = e.clientX - cam.lastX;
      const dy = e.clientY - cam.lastY;
      cam.lastX = e.clientX;
      cam.lastY = e.clientY;

      cam.yaw += dx * 0.005;
      cam.pitch += dy * 0.005;
      cam.pitch = clamp(cam.pitch, -1.3, 1.3);
    });

    c.addEventListener("wheel", (e) => {
      e.preventDefault();
      cam.distance *= Math.exp(e.deltaY * 0.001);
      cam.distance = clamp(cam.distance, 1.5, 25.0);
    }, { passive: false });
  }

  _frame = (now) => {
    const gl = this.gl;

    // Timing
    this.dt = (now - this._last) * 0.001;
    this._last = now;
    this.time += this.dt;

    // Clear
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Build matrices
    const aspect = this.canvas.width / this.canvas.height;
    const proj = Mat4.perspective(60 * Math.PI/180, aspect, 0.1, 100.0);

    const eye = orbitToEye(this.camera.yaw, this.camera.pitch, this.camera.distance, this.camera.target);
    const view = Mat4.lookAt(eye, this.camera.target, [0, 1, 0]);

    // Model (spin cube)
    const model = Mat4.mul(
      Mat4.rotationY(this.time * 0.9),
      Mat4.rotationX(this.time * 0.6)
    );

    const mvp = Mat4.mul(proj, Mat4.mul(view, model));

    // Draw
    gl.useProgram(this.program);
    gl.bindVertexArray(this.mesh.vao);

    gl.uniformMatrix4fv(this.u.uMVP, false, mvp);
    gl.uniformMatrix4fv(this.u.uModel, false, model);
    gl.uniform3fv(this.u.uLightDir, normalize3([0.6, 1.0, 0.4]));
    gl.uniform3fv(this.u.uColor, [0.25, 0.8, 1.0]);

    gl.drawElements(gl.TRIANGLES, this.mesh.indexCount, gl.UNSIGNED_SHORT, 0);

    gl.bindVertexArray(null);
    this._raf = requestAnimationFrame(this._frame);
  };
}

/** =========================
 *  Shaders
 *  ========================= */

const VERT_SRC = `#version 300 es
precision highp float;

layout(location=0) in vec3 aPos;
layout(location=1) in vec3 aNormal;

uniform mat4 uMVP;
uniform mat4 uModel;

out vec3 vN;
out vec3 vWPos;

void main() {
  vec4 wPos = uModel * vec4(aPos, 1.0);
  vWPos = wPos.xyz;

  // Normal matrix (approx; fine for pure rotations)
  vN = mat3(uModel) * aNormal;

  gl_Position = uMVP * vec4(aPos, 1.0);
}
`;

const FRAG_SRC = `#version 300 es
precision highp float;

in vec3 vN;
in vec3 vWPos;

uniform vec3 uLightDir;
uniform vec3 uColor;

out vec4 outColor;

void main() {
  vec3 N = normalize(vN);
  vec3 L = normalize(uLightDir);

  float diff = max(dot(N, L), 0.0);
  float ambient = 0.18;

  // cheap spec
  vec3 V = normalize(-vWPos);
  vec3 H = normalize(L + V);
  float spec = pow(max(dot(N, H), 0.0), 64.0) * 0.25;

  vec3 col = uColor * (ambient + diff) + spec;
  outColor = vec4(col, 1.0);
}
`;

/** =========================
 *  Mesh: Cube
 *  ========================= */

function createCubeMesh(gl) {
  // 24 verts (4 per face), each face ordered CCW when viewed from outside
  const positions = new Float32Array([
    // +X
    1,-1, 1,   1,-1,-1,   1, 1,-1,   1, 1, 1,
    // -X
   -1,-1,-1,  -1,-1, 1,  -1, 1, 1,  -1, 1,-1,
    // +Y
   -1, 1, 1,   1, 1, 1,   1, 1,-1,  -1, 1,-1,
    // -Y
   -1,-1,-1,   1,-1,-1,   1,-1, 1,  -1,-1, 1,
    // +Z
   -1,-1, 1,   1,-1, 1,   1, 1, 1,  -1, 1, 1,
    // -Z
    1,-1,-1,  -1,-1,-1,  -1, 1,-1,   1, 1,-1
  ]);

  const normals = new Float32Array([
    // +X
    1,0,0,  1,0,0,  1,0,0,  1,0,0,
    // -X
   -1,0,0, -1,0,0, -1,0,0, -1,0,0,
    // +Y
    0,1,0,  0,1,0,  0,1,0,  0,1,0,
    // -Y
    0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
    // +Z
    0,0,1,  0,0,1,  0,0,1,  0,0,1,
    // -Z
    0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1
  ]);

  const indices = new Uint16Array([
    0,1,2,  0,2,3,
    4,5,6,  4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ]);

  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

  const nrmBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, nrmBuf);
  gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

  const idxBuf = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  gl.bindVertexArray(null);
  return { vao, indexCount: indices.length };
}


/** =========================
 *  Shader utils
 *  ========================= */

function createShader(gl, type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    const msg = gl.getShaderInfoLog(s) || "Unknown shader error";
    gl.deleteShader(s);
    throw new Error(msg);
  }
  return s;
}

function createProgram(gl, vsSrc, fsSrc) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSrc);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSrc);
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  gl.deleteShader(vs);
  gl.deleteShader(fs);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    const msg = gl.getProgramInfoLog(p) || "Unknown link error";
    gl.deleteProgram(p);
    throw new Error(msg);
  }
  return p;
}

/** =========================
 *  Tiny math (Mat4)
 *  Column-major, WebGL-friendly
 *  ========================= */

const Mat4 = {
  identity() {
    return new Float32Array([
      1,0,0,0,
      0,1,0,0,
      0,0,1,0,
      0,0,0,1
    ]);
  },

  perspective(fovy, aspect, near, far) {
    const f = 1.0 / Math.tan(fovy / 2);
    const nf = 1 / (near - far);
    const out = new Float32Array(16);
    out[0] = f / aspect;
    out[5] = f;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[14] = (2 * far * near) * nf;
    return out;
  },

  lookAt(eye, target, up) {
    const z = normalize3(sub3(eye, target));     // forward
    const x = normalize3(cross3(up, z));         // right
    const y = cross3(z, x);                      // up corrected

    const out = Mat4.identity();
    out[0] = x[0]; out[4] = x[1]; out[8]  = x[2];
    out[1] = y[0]; out[5] = y[1]; out[9]  = y[2];
    out[2] = z[0]; out[6] = z[1]; out[10] = z[2];

    out[12] = -dot3(x, eye);
    out[13] = -dot3(y, eye);
    out[14] = -dot3(z, eye);
    return out;
  },

  rotationX(a) {
    const c = Math.cos(a), s = Math.sin(a);
    return new Float32Array([
      1,0,0,0,
      0,c,s,0,
      0,-s,c,0,
      0,0,0,1
    ]);
  },

  rotationY(a) {
    const c = Math.cos(a), s = Math.sin(a);
    return new Float32Array([
      c,0,-s,0,
      0,1,0,0,
      s,0,c,0,
      0,0,0,1
    ]);
  },

  mul(a, b) {
    // out = a*b
    const out = new Float32Array(16);
    for (let c = 0; c < 4; c++) {
      for (let r = 0; r < 4; r++) {
        out[c*4 + r] =
          a[0*4 + r] * b[c*4 + 0] +
          a[1*4 + r] * b[c*4 + 1] +
          a[2*4 + r] * b[c*4 + 2] +
          a[3*4 + r] * b[c*4 + 3];
      }
    }
    return out;
  }
};

/** =========================
 *  Vec3 helpers
 *  ========================= */

function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

function sub3(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function dot3(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
function cross3(a, b) {
  return [
    a[1]*b[2] - a[2]*b[1],
    a[2]*b[0] - a[0]*b[2],
    a[0]*b[1] - a[1]*b[0]
  ];
}
function len3(v) { return Math.hypot(v[0], v[1], v[2]); }
function normalize3(v) {
  const L = len3(v) || 1;
  return [v[0]/L, v[1]/L, v[2]/L];
}

function orbitToEye(yaw, pitch, dist, target) {
  const cy = Math.cos(yaw), sy = Math.sin(yaw);
  const cp = Math.cos(pitch), sp = Math.sin(pitch);
  const x = dist * cp * sy;
  const y = dist * sp;
  const z = dist * cp * cy;
  return [target[0] + x, target[1] + y, target[2] + z];
}

/** =========================
 *  Boot
 *  ========================= */

const canvas = document.getElementById("gl");
new GLSystem(canvas);
</script>
</body>
</html>
